function genomes = createRandomFolds(tam_poblacion, params, doCreation)

isLazy = isfield(params.genome.fold, 'returnEmptyInGA') && params.genome.fold.returnEmptyInGA;

if isLazy
  %when genome generation is very resource-intensive, we can generate the
  %genomes in the evaluation, but then we must be sure not generating them
  %in the genetic algorithm. For this, we use a thrid parameter which is
  %not passed in the genetic algorithm
  if ~exist('doCreation', 'var') || (~doCreation)
    genomes = repmat({'LAZY_GENERATION'}, tam_poblacion, 1);
    return
  end
end

maxrecur = params.genome.fold.maxRecursion;
genomes = cell(tam_poblacion,1);
for k=1:numel(genomes)
  for j=1:maxrecur
    genomes{k} = createRandomFold(params, isLazy, 0);
    if ~isempty(genomes{k})
      break;
    end
  end
  if isempty(genomes{k})
    error('I''ve grown tired of trying it (%s, %s)!!!!!', mat2str(j), mat2str(maxrecur));
  end
end

function genome = createRandomFold(params, isLazy, recursion)

fold        = params.genome.fold;

if recursion>fold.maxRecursion %maximum depth of recursive calls (recursive calls are used when a non-functional genome is generated by chance)
  error('I''ve grown tired of trying it (%s, %s)!!!!!', mat2str(recursion), mat2str(fold.maxRecursion));
end

n           = fold.numPoints; %number of points in the chain

pos         = zeros(n,3);

lmin        = fold.lmin; %distance between points in the chain
l0          = fold.l0;   %cutoff distance for establishing connections

last        = fold.nlast; %if considerAll==true, only consider the an amount "last" of the newest points. Otherwise, consider all previous points
conns       = fold.nconns; %number of connections which each new point must have with older points

considerAll = fold.considerAll;

maxReps     = fold.maxReps; %maximum number of tries to generate the next point in the chain before giving up

lmin2       = lmin*lmin;

l02         = l0*l0;


for k=2:n
  goon = true;
  r = 0;
%   tn = 0;
  while goon
    vec     = rand(1,3)-0.5;
    vecl    = realsqrt(sum(vec.*vec));
    vec     = vec/vecl*lmin + pos(k-1, :);
    dm      = pos(1:k-1,:);
    dm(:,1) = dm(:,1)-vec(1);
    dm(:,2) = dm(:,2)-vec(2);
    dm(:,3) = dm(:,3)-vec(3);
    dm      = dm.*dm;
    dm      = dm(:,1)+dm(:,2)+dm(:,3);
    if considerAll
      goon  =  any(dm<lmin2) || (sum(dm<l02)<min(conns,k-1));
    else
      goon  =  any(dm<lmin2) || (sum(dm(max(1,k-last+1):k-1)<l02)<min(conns, k-1));
    end
    r = r+1;
    if r>maxReps
      genome = [];%createRandomFold(params, isLazy, recursion+1);
      return
    end
  end
  pos(k,:)  = vec;
end

%snap to grid
if isLazy
  evparams = params;
else
  evparams = params.evparams;
end
[genome pos err] = convertCompressedPos(pos, evparams, false);

if err %if we weren't able to snap it to grid, retry
  genome = [];return %createRandomFold(params, isLazy, recursion+1);
end

conns        = triu(distanceMatrixSquared(pos)<=l02, 1);
[sp1 sp2]    = find(conns);
r            = realsqrt(sum(realpow(pos(sp1,:)-pos(sp2,:), 2), 2));

%the chain might be rendered invalid after snapping to grid
if ~validChain(pos, conns, sp1, sp2, r, evparams)
  genome = [];%createRandomFold(params, isLazy, recursion+1);
end

